#include "rtc.h"

int rtc_l;
int rtc_o;
int data;
int r_i0;
int counter;
extern uint32_t mod_start;
extern uint32_t dir_entries_fs;
extern file_ops_t rtc_ops;

/*INPUT : None
*OUTPUT : NONE
*Effects : This will enable the rtc interrupt. The rtc is on IR0 of the slave
*This also sets the frequency to 2Hz so the screen doesn't get a seizure.*/
void rtc_init(void)
{
	
	//turn on ir8
	enable_irq(IRQ_IR);
	
	char prev;
    /*Thanks OSDev!*/
	counter=0;
    outb(REGB,REGISTERIN); //Select register B, disable NMI.
    prev = inb(REGISTEROUT); // get value of it.
    outb(REGB,REGISTERIN); // A read resets the index, so set it again.
    outb(prev | 0x40, REGISTEROUT); // This should turn on interrupts from the RTC.
    /*Setting the rate of interrupts to 2 Hz (at least by default?)*/
	
    int rate;
    rate = default_rate; //this has to be anded, we have to first get rate from the port

    outb(REGA, REGISTERIN);
    prev = inb(REGA,REGISTEROUT);
    outb(REGA, REGISTERIN); // Index was reset
    outb(rate,REGISTEROUT); // 2 Hz. f = 32768 >> (rate-1)
    rtc_o=0;

}

/*INPUT : NONE
*OUTPUT : Possibly none
*This is the interrupt handler for the RTC, when an interrupt generated by the rtc
*occurs, process will jump here. We will read in a certain value from
*The ports of the RTC, because if we don't do so the interrupt won't happen
*periodically.*/
void rtc_c(void)
{
    /*This ensures that we get another interrupt*/
    //test_interrupts();
	r_i0=0;       
	outb(REGC, REGISTERIN); // select register C
	inb(REGISTEROUT); // just throw away contents, we need to read it at least.
	return;
}

/*INPUT : fd, file descriptor
* OUTPUT : fd (index into the table) on success, -1 otherwise
* EFFECTS : Put in relevant information into the array. See 7.2
*Note : doesn't need to do anything for 3.2. For now, we can actually just not
*pass in anything*/
int
rtc_open(const int8_t* fd)
{
	//int strcomp=1;
	fd_table_entry_t * fd_table_pcb=find_fd_table();
	char prev;
    //sets  hz to 2
	counter=0;
	int index = (*fd);
    int rate;
    rate =  default_rate; //this has to be anded, we have to first get rate from the port

    outb(REGA, REGISTERIN);
    prev = inb(REGA,REGISTEROUT);
    outb(REGA, REGISTERIN); // Index was reset
    outb(rate,REGISTEROUT); // 2 Hz. f = 32768 >> (rate-1)
    rtc_o=0;
	enable_irq(IRQ_IR);

	fd_table_pcb[index].file_op_p=(uint32_t)&rtc_ops;
	fd_table_pcb[index].file_position=0;
	fd_table_pcb[index].inode_p=NULL;
	fd_table_pcb[index].flags=1;

	return index;
}

/*INPUT : nothing
* OUTPUT : 0 on success
*Effects : outputs when there was an interrupt*/
int
rtc_read(int32_t buf, int32_t count, fd_table_entry_t * fd, int buf_size)
{
	r_i0=1;         //gets the current number of interrupts
	
	while(r_i0!=0)         // loops until an interrupt happens
	{ asm("nop"); }
    // printf(" interrupt ");
    // set_attrib(r_i0&0xf, (r_i0/3+1)&0xf);
	return 0;
}

/*INPUT :  r. r is the new rate
*OUTPUT : NONE
*EFFECT : changes the rtc rate to r
*We can't write to the file system, so just return -1*/
int
rtc_write(int32_t r , int32_t count ,fd_table_entry_t * fd )
{
	int* pointer=(int*)r;
	int r2=*pointer;
	int rate=default_rate;
	int loop=2;
	for(loop=2;loop<=PD_SIZE;loop=loop*2)
	{
		
		if(loop==r2)
		{
			break;
		}
		if(loop==PD_SIZE)
			return -1;
		rate=rate-1;
	}
	char prev;
	
     //rate =(r&default_rate);
   // rate = 0x0F; //this has to be anded, we have to first get rate from the port
	disable_irq(IRQ_IR);
    outb(REGA, REGISTERIN);
    prev = inb(REGA,REGISTEROUT);
    outb(REGA, REGISTERIN); // Index was reset
    outb( rate,REGISTEROUT); // 2 Hz. f = 32768 >> (rate-1)
    
	enable_irq(IRQ_IR);
	return 0;
}

/*INPUT : nothing
*OUTPUT : 0 on success, -1 otherwise
*EFFECTS : Removes it from the array
*Note : Doesn't need to do anything for 3.2. For now we can actually not pass in anything*/
int
rtc_close(int8_t fd)
{
	fd_table_entry_t *fd_table_pcb=find_fd_table();
	fd_table_pcb[(int)fd].file_op_p = 0;
    fd_table_pcb[(int)fd].inode_p = 0;
    fd_table_pcb[(int)fd].file_position = 0;
    fd_table_pcb[(int)fd].flags = 0;
	return 0;
}
